<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>meow~</title>
    <url>//post/39498/</url>
    <content><![CDATA[<p>海内存知己，天涯若比邻</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>test post</tag>
      </tags>
  </entry>
  <entry>
    <title>编译过程中遇到的各种问题（持续更新）</title>
    <url>//post/acd9767d/</url>
    <content><![CDATA[<p>我在用gcc编译时出现的错误如下，用ai解决这些问题之后，编译居然成功了<br>但是给我的米板4刷进去之后并不能开机……</p>
<p>二编：我换了个内核进行编译，还想集成kernelsu，可是一直都不成功，气得我鬼火冒</p>
<p>三编：换了魅蓝note6的内核，编译进行地异常顺利，刷进去之后也开机了，可是kernelsu并没有成功集成。。。</p>
<h2 id="NR-CPUS配置错误"><a href="#NR-CPUS配置错误" class="headerlink" title="NR_CPUS配置错误"></a>NR_CPUS配置错误</h2><p>可能出现的报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">include/trace/events/sched.h:875:2: error: <span class="comment">#error &quot;Unsupported NR_CPUS for lb tracepoint.&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑内核配置</span></span><br><span class="line">make menuconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入&quot;General setup&quot; -&gt; &quot;Maximum number of CPUs&quot;</span></span><br><span class="line"><span class="comment"># 将值设置为一个较小的数字（如8或16）</span></span><br><span class="line"><span class="comment"># 保存配置并退出</span></span><br></pre></td></tr></table></figure>

<p>或者编辑内核配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑.config文件</span></span><br><span class="line">vi .config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到并修改CONFIG_NR_CPUS</span></span><br><span class="line">CONFIG_NR_CPUS=8</span><br></pre></td></tr></table></figure>

<h2 id="函数cpuid-feature-extract-field参数不匹配"><a href="#函数cpuid-feature-extract-field参数不匹配" class="headerlink" title="函数cpuid_feature_extract_field参数不匹配"></a>函数<code>cpuid_feature_extract_field</code>参数不匹配</h2><p>可能出现的报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./arch/arm64/include/asm/kvm_mmu.h:309:17: error: too few arguments to <span class="keyword">function</span> <span class="string">&#x27;cpuid_feature_extract_field&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong></p>
<p>编辑文件<code>./arch/arm64/include/asm/kvm_mmu.h</code>，找到第309行附近的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (cpuid_feature_extract_field(reg, ID_AA64MMFR1_VMIDBITS_SHIFT) == <span class="number">2</span>) ? <span class="number">16</span> : <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (cpuid_feature_extract_field(reg, ID_AA64MMFR1_VMIDBITS_SHIFT, <span class="number">0</span>) == <span class="number">2</span>) ? <span class="number">16</span> : <span class="number">8</span>;\</span><br></pre></td></tr></table></figure>

<p>注意：第三个参数的具体值需要根据<code>cpuid_feature_extract_field</code>函数的定义来确定，可能需要查看相关头文件</p>
<h2 id="devfreq-simple-ondemand-data结构体类型不完整"><a href="#devfreq-simple-ondemand-data结构体类型不完整" class="headerlink" title="devfreq_simple_ondemand_data结构体类型不完整"></a><code>devfreq_simple_ondemand_data</code>结构体类型不完整</h2><p>可能出现的报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">include/linux/mmc/host.h:331:54: error: field <span class="string">&#x27;ondemand_gov_data&#x27;</span> has incomplete <span class="built_in">type</span></span><br><span class="line">  331 |         struct          devfreq_simple_ondemand_data ondemand_gov_data;</span><br><span class="line">      |                                                      ^~~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑内核配置</span></span><br><span class="line">make menuconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导航到以下路径并启用选项：</span></span><br><span class="line"><span class="comment"># Device Drivers -&gt; Generic Driver Options -&gt; Devfreq drivers -&gt; Generic Dynamic Voltage and Frequency Scaling (DVFS) support</span></span><br><span class="line"><span class="comment"># 然后启用 &quot;Simple Ondemand&quot; governor</span></span><br></pre></td></tr></table></figure>

<p>或者编辑内核配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用相关配置</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=y&quot;</span> &gt;&gt; .config</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;CONFIG_PM_DEVFREQ=y&quot;</span> &gt;&gt; .config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新生成配置</span></span><br><span class="line">make oldconfig</span><br></pre></td></tr></table></figure>

<h2 id="变量phdr重复声明"><a href="#变量phdr重复声明" class="headerlink" title="变量phdr重复声明"></a>变量phdr重复声明</h2><p>可能出现的报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">drivers/soc/qcom/smem.c: In <span class="keyword">function</span> <span class="string">&#x27;qcom_smem_alloc_private&#x27;</span>:</span><br><span class="line">drivers/soc/qcom/smem.c:305:39: error: redeclaration of <span class="string">&#x27;phdr&#x27;</span> with no linkage</span><br><span class="line">  305 |         struct smem_partition_header *phdr;</span><br><span class="line">      |                                       ^~~~</span><br><span class="line">drivers/soc/qcom/smem.c:303:39: note: previous declaration of <span class="string">&#x27;phdr&#x27;</span> with <span class="built_in">type</span> <span class="string">&#x27;struct smem_partition_header *&#x27;</span></span><br><span class="line">  303 |         struct smem_partition_header *phdr;</span><br><span class="line">      |                                       ^~~~</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑文件 drivers/soc/qcom/smem.c</span></span><br><span class="line">vi drivers/soc/qcom/smem.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到函数 qcom_smem_alloc_private</span></span><br><span class="line"><span class="comment"># 删除第305行的重复声明：</span></span><br><span class="line"><span class="comment"># struct smem_partition_header *phdr;</span></span><br></pre></td></tr></table></figure>

<p>或者用sed命令修复</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除第305行的重复声明</span></span><br><span class="line">sed -i <span class="string">&#x27;305d&#x27;</span> drivers/soc/qcom/smem.c</span><br></pre></td></tr></table></figure>

<h2 id="DTC链接错误"><a href="#DTC链接错误" class="headerlink" title="DTC链接错误"></a>DTC链接错误</h2><p>可能出现的报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/ld: scripts/dtc/dtc-parser.tab.o:(.bss+0x10): multiple definition of `yylloc<span class="string">&#x27;; scripts/dtc/dtc-lexer.lex.o:(.bss+0x0): first defined here</span></span><br><span class="line"><span class="string">collect2: error: ld returned 1 exit status</span></span><br><span class="line"><span class="string">make[3]: *** [scripts/Makefile.host:100：scripts/dtc/dtc] 错误 1</span></span><br><span class="line"><span class="string">make[2]: *** [../scripts/Makefile.build:489：scripts/dtc] 错误 2</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方式：</strong><br>在内核源码根目录中找到<code>Makefile</code>文件<br>然后搜索找到<code>HOSTCFLAGS</code>项，添加<code>HOSTCFLAGS += -fcommon</code><br>重新运行<code>./build.sh</code></p>
<h2 id="编译VDSO时出现的汇编语法错误"><a href="#编译VDSO时出现的汇编语法错误" class="headerlink" title="编译VDSO时出现的汇编语法错误"></a>编译VDSO时出现的汇编语法错误</h2><p>可能出现的报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">../arch/arm64/kernel/vdso/gettimeofday.S:223:24: error: too many positional arguments</span><br><span class="line">clock_gettime_return, <span class="built_in">shift</span>=1</span><br><span class="line">                       ^</span><br></pre></td></tr></table></figure>

<p><strong>解决方式：</strong><br>找到<code>/arch/arm64/kernel/vdso/gettimeofday.S</code>文件<br>然后修改此文件中第223、246和267行的宏调用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 原代码</span><br><span class="line">clock_gettime_return, shift=1</span><br><span class="line"></span><br><span class="line"># 应修改为</span><br><span class="line">clock_gettime_return shift=1</span><br></pre></td></tr></table></figure>

<p>然后重新运行<code>./build.sh</code></p>
<h2 id="ld无法辨认aarch64linux仿真模式"><a href="#ld无法辨认aarch64linux仿真模式" class="headerlink" title="ld无法辨认aarch64linux仿真模式"></a>ld无法辨认aarch64linux仿真模式</h2><p>可能出现的报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/ld: 无法辨认的仿真模式: aarch64linux</span><br><span class="line">支持的仿真： elf_x86_64 elf32_x86_64 elf_i386 elf_iamcu elf_l1om elf_k1om i386pep i386pe</span><br></pre></td></tr></table></figure>

<p><strong>解决方式：</strong><br>移除<code>/bin/ld</code>以确保使用的是<code>/bin/ld.lld</code></p>
<h2 id="编译EFI-stub时的绝对符号引用"><a href="#编译EFI-stub时的绝对符号引用" class="headerlink" title="编译EFI stub时的绝对符号引用"></a>编译EFI stub时的绝对符号引用</h2><p>可能出现的报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">drivers/firmware/efi/libstub/lib-sort.stub.o: absolute symbol references not allowed <span class="keyword">in</span> the EFI stub</span><br><span class="line">make[5]: *** [../drivers/firmware/efi/libstub/Makefile:72：drivers/firmware/efi/libstub/lib-sort.stub.o] 错误 1</span><br><span class="line">make[4]: *** [../scripts/Makefile.build:656：drivers/firmware/efi/libstub] 错误 2</span><br><span class="line">make[3]: *** [../scripts/Makefile.build:656：drivers/firmware/efi] 错误 2</span><br><span class="line">make[2]: *** [../scripts/Makefile.build:656：drivers/firmware] 错误 2</span><br><span class="line">make[1]: *** [/home/abc/android_kernel_meizu_m1721/Makefile:1168：drivers] 错误 2</span><br><span class="line">make[1]: *** 正在等待未完成的任务....</span><br></pre></td></tr></table></figure>

<p><strong>解决方式：</strong><br>修改<code>build.sh</code>，添加禁用efi功能的代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make <span class="variable">$&#123;args&#125;</span> m1721_defconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在编译默认配置代码之后添加禁用 EFI 相关选项</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;禁用 EFI 相关配置...&quot;</span></span><br><span class="line">./scripts/config --file out/.config --<span class="built_in">disable</span> EFI</span><br><span class="line">./scripts/config --file out/.config --<span class="built_in">disable</span> EFI_STUB</span><br><span class="line">./scripts/config --file out/.config --<span class="built_in">disable</span> EFI_RUNTIME_WRAPPERS</span><br><span class="line">./scripts/config --file out/.config --<span class="built_in">disable</span> EFI_CAPSULE_LOADER</span><br><span class="line">./scripts/config --file out/.config --<span class="built_in">disable</span> EFI_TEST</span><br><span class="line"></span><br><span class="line">make <span class="variable">$&#123;args&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>内核编译</tag>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title>南邮数据结构作业1</title>
    <url>//post/f93c4f64/</url>
    <content><![CDATA[<ul>
<li><strong>要求</strong><br>设计算法，将一个带头结点的单链表A分解为两个带头结点的单链表A和B，<br>使得A表中含有原表中序号为奇数的元素，而B表中含有原表中序号为偶数的元素<br>且保持其相对顺序不变</li>
</ul>
<ul>
<li><p><strong>算法思想</strong><br>要求是将单链表中序号奇数和偶数的元素分到两个单链表中，<br>所以创建两个带头结点的单链表M和N，其中M储存原来序号为奇数的元素，N储存原来序号为偶数的元素<br>然后遍历原链表A，当序号为奇数的时候，将对应的元素存储到M，序号为偶数的时候存储到N<br>添加元素的位置均为链表的末尾</p>
<p>要考虑元素之间相对顺序不变，所以还要另外定义两个int变量m和n代表链表M和N的下标<br>每添加一个元素，下标就加1</p>
</li>
</ul>
<p><strong>结点定义</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> ElemType element; <span class="comment">//结点的数据域</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">link</span>;</span> <span class="comment">//结点的指针域</span></span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure>

<p><strong>带头结点的单链表定义</strong>，head作为头节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">headerList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> Node* head;</span><br><span class="line"> <span class="type">int</span> n; <span class="comment">//单链表的长度n</span></span><br><span class="line">&#125;HeaderList;</span><br></pre></td></tr></table></figure>

<p><strong>初始化运算</strong>：生成空表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Init</span><span class="params">(HeaderList* h)</span></span><br><span class="line">&#123;</span><br><span class="line"> h-&gt;head = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">//生成表头结点</span></span><br><span class="line"> <span class="keyword">if</span> (!h-&gt;head)            <span class="comment">//表头结点为空返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> h-&gt;head-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line"> h-&gt;n = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找运算</strong>：根据下标i查找元素，并通过x返回值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(HeaderList L, <span class="type">int</span> i, ElemType* x)</span></span><br><span class="line">&#123;</span><br><span class="line"> Node* p;</span><br><span class="line"> <span class="type">int</span> j;</span><br><span class="line"> <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; L.n<span class="number">-1</span>)        <span class="comment">//对i进行越界检查</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> p = L.head-&gt;link;</span><br><span class="line"> <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++)            <span class="comment">//从头结点开始查找下标i的元素</span></span><br><span class="line">     p = p-&gt;link;</span><br><span class="line"></span><br><span class="line"> *x = p-&gt;element;                <span class="comment">//通过x返回元素值（传地址）</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入运算</strong>：根据下标i插入元素x</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Insert</span><span class="params">(HeaderList* h, <span class="type">int</span> i, ElemType x)</span></span><br><span class="line">&#123;</span><br><span class="line"> Node* p, * q;</span><br><span class="line"> <span class="type">int</span> j;</span><br><span class="line"> <span class="keyword">if</span> (i&lt;<span class="number">-1</span> || i&gt;h-&gt;n - <span class="number">1</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> p = h-&gt;head;                      <span class="comment">//从头结点开始找a(i)元素所在的结点p</span></span><br><span class="line"> <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">     p = p-&gt;link;</span><br><span class="line"></span><br><span class="line"> q = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//生成新结点q</span></span><br><span class="line"></span><br><span class="line"> q-&gt;element = x;                    <span class="comment">//将元素x赋值到新结点q</span></span><br><span class="line"> q-&gt;link = p-&gt;link;              <span class="comment">//将新结点q插在p之后</span></span><br><span class="line"> p-&gt;link = q;</span><br><span class="line"> h-&gt;n++;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出运算</strong>：输出链表的所有元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Output</span><span class="params">(HeaderList* L)</span></span><br><span class="line">&#123;</span><br><span class="line"> Node* p;</span><br><span class="line"> <span class="keyword">if</span> (!L-&gt;n)                        <span class="comment">//判空运算</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> p = L-&gt;head-&gt;link;</span><br><span class="line"> <span class="keyword">while</span> (p)                        <span class="comment">//依次输出每个元素</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;element);</span><br><span class="line">     p = p-&gt;link;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>主程序步骤</strong><br>1.先生成原链表A和待存储链表M和N，以及对应的下标m和n<br>  (M储存原来序号为奇数的元素，N储存原来序号为偶数的元素)<br>2.使用查找运算遍历链表A，用变量x存储返回值<br>3.用if语句根据下标的奇偶性将a插入链表M和N中<br>4.当链表A遍历完成后，输出链表A、M和N，验证程序是否有错误</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> HeaderList A, M, N;</span><br><span class="line"> <span class="type">int</span> i, m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"> Init(&amp;A);        <span class="comment">//初始化链表</span></span><br><span class="line"> Init(&amp;M);</span><br><span class="line"> Init(&amp;N);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)        <span class="comment">//给链表A插入0~9</span></span><br><span class="line">     Insert(&amp;A, i - <span class="number">1</span>, i);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;原List:&quot;</span>);    <span class="comment">//输出链表A</span></span><br><span class="line"> Output(&amp;A);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line">     Find(A, i, &amp;x);            <span class="comment">//用查找运算遍历链表A，用x存储返回值</span></span><br><span class="line">     <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         Insert(&amp;M, m - <span class="number">1</span>, x);    <span class="comment">//下标为奇数时，将元素添加至链表M</span></span><br><span class="line">         m++;    <span class="comment">//m表示链表M的下标</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         Insert(&amp;N, n - <span class="number">1</span>, x);    <span class="comment">//下标为偶数时，加元素添加至链表N</span></span><br><span class="line">         n++;    <span class="comment">//n表示链表N的下标</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\nList（奇数下标）:&quot;</span>);</span><br><span class="line"> Output(&amp;M);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\nList（偶数下标）:&quot;</span>);</span><br><span class="line"> Output(&amp;N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">原List:0 1 2 3 4 5 6 7 8</span><br><span class="line">List（奇数下标）:1 3 5 7</span><br><span class="line">List（偶数下标）:0 2 4 6 8</span><br><span class="line">E:\Buildings\c\数据结构与算法作业\第二章作业\x64\Debug\第二章作业.exe (进程 12624)已退出，代码为 0 (0x0)。</span><br><span class="line">要在调试停止时自动关闭控制台，请启用“工具”-&gt;“选项”-&gt;“调试”-&gt;“调试停止时自动关闭控制台”。</span><br><span class="line">按任意键关闭此窗口. . .</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title>使用dd命令提取boot</title>
    <url>//post/e8bec2d1/</url>
    <content><![CDATA[<h2 id="教程开始"><a href="#教程开始" class="headerlink" title="教程开始"></a>教程开始</h2><ul>
<li><strong>首先在手机上启用开发者选项，并打开以root身份的adb调试</strong></li>
</ul>
<p>设置导航到关于手机，连续点击版本号直到出现“你已启用开发者选项”<br>然后找到开发者选项，找到“adb调试”和“以root身份的调试”并打开<br>如果开发者选项中没有“以root身份的调试”，那么你首先得获取root权限</p>
<ul>
<li><strong>手机连接电脑，然后在电脑上以打开adb</strong></li>
</ul>
<p>win+R输入cmd唤出命令提示符，然后输入<code>adb devices</code>来检测设备：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\29395&gt;adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">721QAD4S44CXQ   device	#检测到设备会像这样子显示</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要事先将adb所在目录添加到系统变量才能直接在cmd中打开adb，如果没有添加的话必须先定位到adb所在目录</p>
</blockquote>
<p>检测到设备后，输入<code>adb root</code>以root身份打开adb</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\29395&gt;adb root</span><br><span class="line">restarting adbd as root</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果开发者选项中没有“以root身份的调试”，可以不用做这一步</p>
</blockquote>
<ul>
<li><strong>进入shell，然后找到boot所在的目录</strong></li>
</ul>
<p>输入<code>adb shell</code>，进入shell</p>
<blockquote>
<p>若上一步没有用root身份打开adb，进入shell后输入su就可以让shell获取root权限（前提是你已经root）</p>
</blockquote>
<p>然后输入<code>cd /dev/block/by-name</code>进入boot所在目录<br>再输入<code>ls -l boot</code>查看boot的具体路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\29395&gt;adb shell</span><br><span class="line">m1721:/ # cd /dev/block/by-name</span><br><span class="line">m1721:/dev/block/by-name # ls -l boot</span><br><span class="line">lrwxrwxrwx 1 root root 21 1970-01-01 09:47 boot -&gt; /dev/block/mmcblk0p21		#这里的/dev/block/mmcblk0p21就是boot的真实路径</span><br><span class="line">m1721:/dev/block/by-name #</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在较新的手机都是Vab分区，所以会存在boot_a和boot_b，按需提取即可</p>
</blockquote>
<ul>
<li><strong>使用dd命令提取boot</strong></li>
</ul>
<p>复制boot的路径，输入<code>dd if=&lt;复制的boot路径&gt; of=/sdcard/boot.img</code>来提取</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">m1721:/dev/block/by-name # dd if=/dev/block/mmcblk0p21 of=/sdcard/boot.img</span><br><span class="line">65536+0 records in</span><br><span class="line">65536+0 records out</span><br><span class="line">33554432 bytes (32 M) copied, 0.625224 s, 51 M/s</span><br><span class="line">m1721:/dev/block/by-name #</span><br></pre></td></tr></table></figure>
<p>这个时候在手机上打开文件管理器，就能在根目录找到刚刚提取的<code>boot.img</code>了</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SakuraFrp实现mc的流畅联机</title>
    <url>//post/a4b13916/</url>
    <content><![CDATA[<h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>搭建网站之前我有想过把我旧手机拿来当服务器<br>我还因此了解到内网穿透这东西<br>发现可以直接用Github直接搭网站之后就放一边了</p>
<p>这两天玩ow给我玩到破防，想着换个游戏玩玩<br>然后就想到mc联机<br>之前用Radmin LAN和KatoLAN搞虚拟局域网的效果不好<br>所以试试内网穿透，暑假的时候同学用过，效果还挺好<br>想到又可以拉朋（hei）友（nu）一起玩就很爽（</p>
<h2 id="教程开始"><a href="#教程开始" class="headerlink" title="教程开始"></a>教程开始</h2><p>首先进入 <a href="https://www.natfrp.com/">Sakura Frp官网</a> 然后点击注册账号<br>注册好之后登入账号，进入管理面板<br><img src="/images/passage3/step1.png"></p>
<p>然后点击用户–实名认证，按步骤进行实名认证（不实名认证无法使用内网穿透）<br>实名认证名额需要购买，价格为1元<br><img src="/images/passage3/step2.png"></p>
<p>认证完成之后 <a href="https://www.natfrp.com/tunnel/download">下载SakuraFrp启动器</a> 并安装<br>启动器界面应如下图所示<br><img src="/images/passage3/step3.png"><br>这时回到官网的管理面板，点击用户–个人信息，复制访问密钥，再填入上图启动器中登录<br><img src="/images/passage3/step4.png"></p>
<p>现在来创建隧道<br>点击服务–隧道列表，再点击创建隧道<br><img src="/images/passage3/step5.png"><br>节点任意选（可能选离自己所在地更近的节点连接效果更好），然后选择TCP隧道<br>隧道名随便填<br>本地ip选择“本地主机(127.0.0.1)”<br>本地端口选择“[25565]Minecraft Java”<br>剩下的选项如果你看不懂就不要管，默认会设置好<br>然后点击“创建”<br><img src="/images/passage3/step6.png"></p>
<p>然后打开mc，开启“对局域网开放”<br>这时候打开Frp启动器，开启隧道，进入日志界面<br>隧道会自动检测mc对局域网开放的端口并提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP隧道启动成功</span><br><span class="line">发现 Minecraft 局域网游戏, 本地 IP/端口 已经设置</span><br><span class="line">使用 &gt;&gt;frp-bar.com:xxxxx&lt;&lt; 连接你的隧道</span><br></pre></td></tr></table></figure>
<p>这时候你就可以将上面的链接复制给你的好友让他进入你的房间了</p>
<p>如果有更多问题，参阅官网的 <a href="https://doc.natfrp.com/app/mc.html">帮助文档</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>Frp</tag>
        <tag>我的世界</tag>
      </tags>
  </entry>
  <entry>
    <title>（转载）为非gki内核添加KernelSU支持</title>
    <url>//post/57133/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Non-gki内核中添加KernelSU的前提得是编译好的内核能够正常开机（废话+1），所以本文也将会详细介绍安卓内核的编译过程以及在编译过程中可能遇到的情况.<br>​写这个文章不是因为我技术有多好，只是因为我刚开始搞这个跟个伞兵一样找不到路，所以现在稍微明白点了就写下来给想搞这个的看看，也是为了防止我自己以后忘了。。奶子不大好使记不住东西</p>
<blockquote>
<p>如果你只是想编译内核而不是使用kernelsu，你可以忽略本文中拉去kernelsu和修改内核配置的部分</p>
</blockquote>
<h3 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><p>一台Linux设备（虚拟机，Docker，WSL，甚至是手机上的Terumx都是可以的），我这里以WSL2，Ubuntu 22.04.2 LTS为例</p>
<p>一部可以正常使用的安卓手机（废话+2）</p>
<p>可以让你连接到github和google的方法（你懂的§(￣▽￣)§）</p>
<p>最后再带上你聪明的小脑袋瓜，粗发！</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li>首先需要下载所需要的依赖，跟坨屎一样多，直接复制执行就好</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git ccache automake flex lzop bison gperf build-essential zip curl zlib1g-dev g++-multilib libxml2-utils bzip2 libbz2-dev libbz2-1.0 libghc-bzlib-dev squashfs-tools pngcrush schedtool dpkg-dev liblz4-tool make optipng maven libssl-dev pwgen libswitch-perl policycoreutils minicom libxml-sax-base-perl libxml-simple-perl bc libc6-dev-i386 lib32ncurses5-dev libx11-dev lib32z-dev</span><br></pre></td></tr></table></figure>

<ul>
<li>下载适合自己手机的内核build</li>
</ul>
<p>这个东西需要自己去Github找，一般为<code>(android)_kernel_&lt;手机厂商&gt;_&lt;cpu代号&gt;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以一加8T为例，高通骁龙865代号为sm8250，那么内核仓库名就可能是</span></span><br><span class="line">android_kernel_oneplus_sm8250</span><br><span class="line">kernel_oneplus_sm8250</span><br></pre></td></tr></table></figure>

<p>我这里的例子是Handelinkernel-v2.6，我在氢的时候最喜欢的一个内核（同时也是最喜欢的一个版本）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仓库地址</span></span><br><span class="line">https://git.drg.fi/drgreen/android_kernel_oneplus_sm8250.git</span><br></pre></td></tr></table></figure>

<ul>
<li>下载所需的交叉编译器</li>
</ul>
<p>​ 由于这个内核自带了编译脚本，所以我们就根据脚本里的的clang版本下载(至于编译脚本我后面再说)<br><strong>当然，其实我更推荐第三方的<em>clang</em>，因为比较省事</strong>比如：<a href="https://github.com/ZyCromerZ/Clang">ZyC clang</a> 、<a href="https://github.com/kdrag0n/proton-clang">proton-clang</a> 或者<a href="https://github.com/Neutron-Toolchains/clang-build-catalogue">clang-build-catalogue</a><br>使用方法也都差不多，当然你也可以使用谷歌官方的clang不过第三方有的更省事直接用就完事了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以我为例，我把它们分别放在了</span></span><br><span class="line">~/android/clang-r407598b</span><br><span class="line">~/android/toolchain</span><br></pre></td></tr></table></figure>

<h2 id="拉取资源"><a href="#拉取资源" class="headerlink" title="拉取资源"></a>拉取资源</h2><ul>
<li>拉取内核源码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span>到用户文件夹</span></span><br><span class="line">cd ~</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取内核,有的内核还有submodules，所以直接加上--recurse-submodules</span></span><br><span class="line">git clone --recurse-submodules https://git.drg.fi/drgreen/android_kernel_oneplus_sm8250.git</span><br></pre></td></tr></table></figure>

<ul>
<li>拉取交叉编译工具<br><strong>aosp-clang和第三方clang选其中一个就好</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">aosp-clang</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建文件夹让后直接curl</span></span><br><span class="line">mkdir ~/android</span><br><span class="line">cd ~/android</span><br><span class="line">curl &lt;需要拉取的clang连接&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">具体版本在这找</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+/refs/heads/main</span></span><br></pre></td></tr></table></figure>

<p>按这个图片找对应版本<br><img src="/images/passage2/step2.1.png"></p>
<p>找到需要的版本后看下图<br><img src="/images/passage2/step2.2.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第三方clang(以Zyclang举例)，在github仓库的release</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制链接直接在当前用户目录下curl</span></span><br><span class="line">mkdir ~/android</span><br><span class="line">cd ~/android</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">记得选择对应版本</span></span><br><span class="line">curl &lt;下图获取的连接&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/images/passage2/step2.3.png"></p>
<ul>
<li>拉取kernelsu</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/&lt;内核文件夹&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在内核文件夹的根目录执行以下命令</span></span><br><span class="line">curl -LSs <span class="string">&quot;https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh&quot;</span> | bash -s v0.9.5</span><br></pre></td></tr></table></figure>

<blockquote>
<p>KernelSU 1.0 及更高版本已经不再支持非 GKI 内核，最后的支持版本为 v0.9.5，请注意使用正确的版本。</p>
</blockquote>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><ul>
<li>修改配置文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/android_kernel_oneplus_sm8250/arch/arm64/configs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时你所需要的配置文件可能在./defconfig</span></span><br><span class="line"><span class="comment"># 但大概率可能会在./vendor/&lt;配置文件&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以本内核为例</span></span><br><span class="line">vi /vendor/kona-perf_defconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在配置文件最底下加上</span></span><br><span class="line">CONFIG_KPROBES=y</span><br><span class="line">CONFIG_HAVE_KPROBES=y</span><br><span class="line">CONFIG_KPROBE_EVENTS=y</span><br></pre></td></tr></table></figure>

<h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进去内核的根目录</span></span><br><span class="line">cd ~/android_kernel_oneplus_sm8250</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个shell文件</span></span><br><span class="line">vim ./build.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入以下内容</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">shell开始</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">export ARCH=arm64</span><br><span class="line">export SUBARCH=arm64</span><br><span class="line"></span><br><span class="line">args=&quot;-j$(nproc --all) \</span><br><span class="line">O=out \</span><br><span class="line">CC=clang \</span><br><span class="line">ARCH=arm64 \</span><br><span class="line">LD=ld.lld \</span><br><span class="line">LLVM=1 \</span><br><span class="line">LLVM_IAS=1 \</span><br><span class="line">CROSS_COMPILE=aarch64-linux-gnu- \</span><br><span class="line">CROSS_COMPILE_COMPAT=arm-linux-gnueabi- &quot;		#根据需要可将COMPAT改为ARM32</span><br><span class="line"></span><br><span class="line">export PATH=&quot;$HOME/&lt;clang文件夹路径&gt;/bin:$PATH&quot;</span><br><span class="line">make $&#123;args&#125; vendor/kona-perf_defconfig</span><br><span class="line">make $&#123;args&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">shell结束</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存后退出，给shell执行权限</span></span><br><span class="line">chmod a+x ./buids.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行,用<span class="built_in">source</span>方便报错后调试</span></span><br><span class="line">source ./build.sh</span><br></pre></td></tr></table></figure>

<h2 id="试验"><a href="#试验" class="headerlink" title="试验"></a>试验</h2><p>如果你足够幸运的话，那么你现在已经成功一半了<br>去内核文件夹的out&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;文件夹看看你的成果<br>把<em>Image</em>放入Anykernel中然后压缩刷入(不同内核压缩方式不同，比如：Image.gz）<br><a href="https://github.com/tiann/KernelSU/discussions/952#discussion-5623210">Anykernel的使用方法</a></p>
<h2 id="恭喜你，看来你不是幸运儿"><a href="#恭喜你，看来你不是幸运儿" class="headerlink" title="恭喜你，看来你不是幸运儿"></a>恭喜你，看来你不是幸运儿</h2><p>如果你此时将内核刷入后发现各种问题，比如黑屏，重启，高通崩溃（甚至你的out路径里根本就没有出现镜像文件），又或者你编译时报错，所以我将会继续为你排忧解难</p>
<ul>
<li>如果你刷入内核后手机不能正常启动，你可以需要按照术哥（kernelsu的作者，就是那只皮卡丘）的办法，放弃使用kprobe集成的办法，转去修改那么几个内核文件，具体请参考 <a href="https://kernelsu.org/zh_CN/guide/how-to-integrate-for-non-gki.html">https://kernelsu.org/zh_CN/guide/how-to-integrate-for-non-gki.html</a> 中手动修改内核源码部分的内容。在修改完成后再次拉取kernelsu(只是为了执行那个脚本，当然你也可以在内核根文件夹内执行kernelsu的脚本)</li>
</ul>
<p>————————————————<br>版权声明：本文为CSDN博主「果呆皮」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_43283565/article/details/137374337">为非gki内核添加KernelSU支持</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>内核编译</tag>
        <tag>安卓刷机</tag>
      </tags>
  </entry>
  <entry>
    <title>用gcc编译老内核（步骤篇）</title>
    <url>//post/50843/</url>
    <content><![CDATA[<h2 id="准备条件："><a href="#准备条件：" class="headerlink" title="准备条件："></a>准备条件：</h2><ul>
<li>一台linux虚拟机（比如我用的Ubuntu 22.04)</li>
<li>一部比较老的测试用设备（比如我手上的米板4）</li>
<li>一个聪明的大脑</li>
</ul>
<h2 id="安装gcc和各种依赖"><a href="#安装gcc和各种依赖" class="headerlink" title="安装gcc和各种依赖"></a>安装gcc和各种依赖</h2><p>依赖部分是我从 <a href="https://blog.csdn.net/qq_43283565/article/details/137374337">另一个教程</a> 里搞来的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install git ccache automake flex lzop bison gperf build-essential zip curl zlib1g-dev g++-multilib libxml2-utils bzip2 libbz2-dev libbz2-1.0 libghc-bzlib-dev squashfs-tools pngcrush schedtool dpkg-dev liblz4-tool make optipng maven libssl-dev pwgen libswitch-perl policycoreutils minicom libxml-sax-base-perl libxml-simple-perl bc libc6-dev-i386 lib32ncurses5-dev libx11-dev lib32z-dev</span><br></pre></td></tr></table></figure>

<p>gcc是编译内核必须的工具链，没有安装gcc就绝对不能编译</p>
<p>安装gcc aarch64和arm32的代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装gcc aarch64</span></span><br><span class="line"><span class="built_in">sudo</span> apt install gcc-aarch64-linux-gnu</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装gcc arm32</span></span><br><span class="line"><span class="built_in">sudo</span> apt install gcc-arm-linux-gnueabi</span><br></pre></td></tr></table></figure>

<p>安装后输出版本号确认</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aarch64-linux-gnu-gcc --version</span><br><span class="line">arm-linux-gnueabi-gcc --version</span><br></pre></td></tr></table></figure>

<h2 id="获取内核源代码"><a href="#获取内核源代码" class="headerlink" title="获取内核源代码"></a>获取内核源代码</h2><p>源代码一般在github就能找到<br>先进入 <a href="https://github.com/">github</a> 官网，然后在搜索栏中输入android_kernel_(品牌)_(机型)，回车搜索</p>
<p>比如小米平板4的品牌是xiaomi，机型是clover：<br><img src="/images/passage1/step1.1.png"></p>
<p>然后挑选你中意的内核点进去，再点击那个绿色的”Code”按钮复制clone链接<br>就是那个两个方框连起来那个链接<br><img src="/images/passage1/step1.2.png"></p>
<p>然后在虚拟机里唤出终端（ctrl + alt + T），输入代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> (你复制到的代码)</span><br></pre></td></tr></table></figure>

<p>一切顺利的话，git就会将内核源代码clone到<code>home/android_kernel_(品牌)_(机型)</code>了<br>当然，如果clone过程报错，挂个梯子再试试<br>如果还是出现问题，问问ai更好</p>
<h2 id="配置编译环境"><a href="#配置编译环境" class="headerlink" title="配置编译环境"></a>配置编译环境</h2><p>我试过很多的教程，它们用的都是编译脚本，可是全都失败了<br>我问deepseek之后才勉强编译出来一个内核（虽然没有开机）<br>如果之后我用编译脚本成功编译出来内核，我应该会修改这一部分</p>
<p>现在先进入内核根目录吧：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/android_kernel_(品牌)_(机型)</span><br></pre></td></tr></table></figure>

<p>首先按照目标架构选择工具链：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对于ARM64 (aarch64)</span></span><br><span class="line"><span class="built_in">export</span> ARCH=arm64</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=aarch64-linux-gnu-</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于ARM32</span></span><br><span class="line"><span class="built_in">export</span> ARCH=arm</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=arm-linux-gnueabi-</span><br></pre></td></tr></table></figure>

<p>然后配置内核</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make defconfig  <span class="comment"># 使用默认配置</span></span><br></pre></td></tr></table></figure>

<h2 id="开始编译内核"><a href="#开始编译内核" class="headerlink" title="开始编译内核"></a>开始编译内核</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j$(<span class="built_in">nproc</span>)  <span class="comment"># 使用所有可用核心编译</span></span><br></pre></td></tr></table></figure>

<p>如果你非常非常幸运，那么这一步你将得到编译完成的内核<br>一般情况下，编译完成的内核存放在：<br><code>~/arch/arm64/boot/Image</code> - 未压缩的内核镜像<br><code>~/arch/arm64/boot/Image.gz</code> - 压缩的内核镜像<br>如果编译的是arm32的内核，镜像文件可能为<code>zImage</code></p>
<p>但实际上你很不幸，编译过程中出现了很多错误<br>而且因为报错内容又臭又长，你基本看不懂也不会想去研究<br>下一篇我就会编译过程中碰到的所有错误和解决办法列出来</p>
<h2 id="可用的替代方案：使用Android预构建工具链"><a href="#可用的替代方案：使用Android预构建工具链" class="headerlink" title="可用的替代方案：使用Android预构建工具链"></a>可用的替代方案：使用Android预构建工具链</h2><p>如果系统GCC版本太新，导致出现各种问题，考虑使用Android官方工具链：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载Android NDK</span></span><br><span class="line">wget https://dl.google.com/android/repository/android-ndk-r21e-linux-x86_64.zip</span><br><span class="line">unzip android-ndk-r21e-linux-x86_64.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用NDK工具链</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/path/to/android-ndk-r21e/toolchains/llvm/prebuilt/linux-x86_64/bin</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>内核编译</tag>
        <tag>安卓</tag>
      </tags>
  </entry>
</search>
